<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lbfgs (lbfgs.Lbfgs)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">lbfgs</a> &#x00BB; Lbfgs</nav><header class="odoc-preamble"><h1>Module <code><span>Lbfgs</span></code></h1><p>Binding to <a href="http://users.eecs.northwestern.edu/~nocedal/lbfgsb.html">L-BFGS-B</a>. These is a limited-memory quasi-Newton code for unconstrained and for bound-constrained optimization.</p><p>The authors of the original FORTRAN code expect that if you use their software in a publication, you quote one of these references:</p><ul><li>R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound Constrained Optimization, (1995), SIAM Journal on Scientific and Statistical Computing , 16, 5, pp. 1190-1208.</li><li>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained optimization (1997), ACM Transactions on Mathematical Software, Vol 23, Num. 4, pp. 550-560.</li><li>J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained optimization (2011), to appear in ACM Transactions on Mathematical Software.</li></ul><ul class="at-tags"><li class="version"><span class="at-tag">version</span> 0.9.3-12-g6a5fa64</li></ul></header><nav class="odoc-toc"><ul><li><a href="#accessing-the-state">Accessing the state</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-work"><a href="#type-work" class="anchor"></a><code><span><span class="keyword">type</span> work</span></code></div><div class="spec-doc"><p>Represent the memory space needed to solve a minimization problem. It is usually allocated automatically but it is possible to do it manually to, say, allocate it once only before a loop.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Abnormal"><a href="#exception-Abnormal" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Abnormal</span> <span class="keyword">of</span> float * string</span></code></div><div class="spec-doc"><p><code>Abnormal(f, msg)</code> is raised if the routine terminated abnormally without being able to satisfy the termination conditions. In such an event, the variable <code>x</code> (see <a href="F/index.html#val-min"><code>F.min</code></a>) will contain the current best approximation found and <code>f</code> is the value of the target function at <code>x</code>. <code>msg</code> is a message containing additional information (returned by the original FORTRAN code).</p><p>If the error message is not precise enough, it is recommended to turn printing on to understand what is the problem.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-print"><a href="#type-print" class="anchor"></a><code><span><span class="keyword">type</span> print</span><span> = </span></code><ol><li id="type-print.No" class="def variant constructor anchored"><a href="#type-print.No" class="anchor"></a><code><span>| </span><span><span class="constructor">No</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>No output is generated.</p><span class="comment-delim">*)</span></div></li><li id="type-print.Last" class="def variant constructor anchored"><a href="#type-print.Last" class="anchor"></a><code><span>| </span><span><span class="constructor">Last</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print one line at the last iteration.</p><span class="comment-delim">*)</span></div></li><li id="type-print.Every" class="def variant constructor anchored"><a href="#type-print.Every" class="anchor"></a><code><span>| </span><span><span class="constructor">Every</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Every k</code> prints the value of the function and |proj gradient| every <code>k</code> iterations. Valid values are <code>0 &lt;= k &lt;= 98</code>, otherwise the closer value in that interval is used.</p><span class="comment-delim">*)</span></div></li><li id="type-print.Details" class="def variant constructor anchored"><a href="#type-print.Details" class="anchor"></a><code><span>| </span><span><span class="constructor">Details</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print details of every iteration (except vectors).</p><span class="comment-delim">*)</span></div></li><li id="type-print.All" class="def variant constructor anchored"><a href="#type-print.All" class="anchor"></a><code><span>| </span><span><span class="constructor">All</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print details of every iteration (except vectors) including changes of active set and final x.</p><span class="comment-delim">*)</span></div></li><li id="type-print.Full" class="def variant constructor anchored"><a href="#type-print.Full" class="anchor"></a><code><span>| </span><span><span class="constructor">Full</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print details of every iteration including x and g.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Control of the frequency at which information is outputted.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div><div class="spec-doc"><p>Holds informations on the current state of the computation that can help to decide whether to stop.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-F"><a href="#module-F" class="anchor"></a><code><span><span class="keyword">module</span> <a href="F/index.html">F</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Fortran Layout.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-C"><a href="#module-C" class="anchor"></a><code><span><span class="keyword">module</span> <a href="C/index.html">C</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>C layout.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-work"><a href="#val-work" class="anchor"></a><code><span><span class="keyword">val</span> work : <span><span class="optlabel">?corrections</span>:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-work">work</a></span></code></div><div class="spec-doc"><p><code>work n</code> allocate the work space for a problem of size at most <code>n</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">corrections</span> <p>See <a href="F/index.html#val-min"><code>F.min</code></a>.</p></li></ul></div></div><h3 id="accessing-the-state"><a href="#accessing-the-state" class="anchor"></a>Accessing the state</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_constrained"><a href="#val-is_constrained" class="anchor"></a><code><span><span class="keyword">val</span> is_constrained : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tells whether the problem is constrained.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nintervals"><a href="#val-nintervals" class="anchor"></a><code><span><span class="keyword">val</span> nintervals : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The total number of intervals explored in the search of Cauchy points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nskipped_updates"><a href="#val-nskipped_updates" class="anchor"></a><code><span><span class="keyword">val</span> nskipped_updates : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The total number of skipped BFGS updates before the current iteration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The number of current iteration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nupdates"><a href="#val-nupdates" class="anchor"></a><code><span><span class="keyword">val</span> nupdates : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The total number of BFGS updates prior the current iteration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nintervals_current"><a href="#val-nintervals_current" class="anchor"></a><code><span><span class="keyword">val</span> nintervals_current : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The number of intervals explored in the search of Cauchy point in the current iteration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neval"><a href="#val-neval" class="anchor"></a><code><span><span class="keyword">val</span> neval : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The total number of function and gradient evaluations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neval_current"><a href="#val-neval_current" class="anchor"></a><code><span><span class="keyword">val</span> neval_current : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The number of function value or gradient evaluations in the current iteration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-previous_f"><a href="#val-previous_f" class="anchor"></a><code><span><span class="keyword">val</span> previous_f : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Returns f(x) in the previous iteration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-norm_dir"><a href="#val-norm_dir" class="anchor"></a><code><span><span class="keyword">val</span> norm_dir : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>2-norm of the line search direction vector.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eps"><a href="#val-eps" class="anchor"></a><code><span><span class="keyword">val</span> eps : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The machine precision epsmch generated by the code.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-time_cauchy"><a href="#val-time_cauchy" class="anchor"></a><code><span><span class="keyword">val</span> time_cauchy : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The accumulated time spent on searching for Cauchy points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-time_subspace_min"><a href="#val-time_subspace_min" class="anchor"></a><code><span><span class="keyword">val</span> time_subspace_min : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The accumulated time spent on subspace minimization.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-time_line_search"><a href="#val-time_line_search" class="anchor"></a><code><span><span class="keyword">val</span> time_line_search : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The accumulated time spent on line search.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slope"><a href="#val-slope" class="anchor"></a><code><span><span class="keyword">val</span> slope : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The slope of the line search function at the current point of line search.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slope_init"><a href="#val-slope_init" class="anchor"></a><code><span><span class="keyword">val</span> slope_init : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The slope of the line search function at the starting point of the line search.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-normi_grad"><a href="#val-normi_grad" class="anchor"></a><code><span><span class="keyword">val</span> normi_grad : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The infinity norm of the projected gradient</p></div></div></div></body></html>
